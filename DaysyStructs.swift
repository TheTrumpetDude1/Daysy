//
//  DaysyStructs.swift
//  Daysy
//
//  Created by Alexander Eischeid on 11/13/23.
//

import Foundation
import SwiftUI
import AVFoundation
import PhotosUI
import NaturalLanguage
import Network
import MobileCoreServices
import OpenAI
import Combine
import MessageUI

struct Account: Codable, Equatable, Identifiable {
    var id: UUID? // Optional to handle creation where id is generated by Supabase
    var first_name: String
    var last_name: String
    let user_name: String
    let password: String
    let email: String
    var sheet_array: [SheetObject]
    var communication_board: [[String]]
    var usage: [UsageData]
    var custom_pecs_addresses: [String: String]
    var custom_pecs_images: [String: Data]
    var settings: [String : Bool]
    var curr_voice_ratio: Double
    var curr_voice: String
    let created_at: Date?
    
    init(id: UUID? = nil, first_name: String = "", last_name: String, user_name: String, password: String, email: String, sheet_array: [SheetObject] = loadSheetArray(), communication_board: [[String]] = loadCommunicationBoard(), usage: [UsageData] = getUsage(), custom_pecs_addresses: [String : String] = getCustomPECSAddresses(), settings: [String : Bool] = getSettings(), curr_voice_ratio: Double = defaults.double(forKey: "currVoiceRatio"), curr_voice: String = defaults.string(forKey: "currVoice") ?? "com.apple.ttsbundle.Daniel-compact", custom_pecs_images: [String: Data] = getCustomPECSImagesData(), created_at: Date = Date()) {
        self.id = id
        self.first_name = first_name
        self.last_name = last_name
        self.user_name = user_name
        self.password = password
        self.email = email
        self.sheet_array = sheet_array
        self.communication_board = communication_board
        self.usage = usage
        self.custom_pecs_addresses = custom_pecs_addresses
        self.settings = settings
        self.curr_voice_ratio = curr_voice_ratio
        self.curr_voice = curr_voice
        self.custom_pecs_images = custom_pecs_images
        self.created_at = created_at    }
    static func == (lhs: Account, rhs: Account) -> Bool {
        return lhs.id == rhs.id
    }
}

struct JSONAccount: Codable, Equatable, Identifiable {
    var id: UUID? // Optional to handle creation where id is generated by Supabase
    var first_name: String?
    var last_name: String?
    let user_name: String?
    let password: String?
    let email: String?
    var sheet_array: Data? //[SheetObject]
    var communication_board: Data? //[[String]]
    var usage: Data? //[UsageData]
    var custom_pecs_addresses: Data? //[String: String]
    var custom_pecs_images: Data? //[String: Data]
    var settings: Data? //[String : Bool]
    var curr_voice_ratio: Double?
    var curr_voice: String?
    let created_at: Date?
    
    static func == (lhs: JSONAccount, rhs: JSONAccount) -> Bool {
        return lhs.id == rhs.id
    }
}

struct UsageDataUpload: Codable, Equatable, Identifiable {
    var id: UUID
    let app_version: String?
    let bundle_version: String?
    let device_model: String?
    let device_identifier: String?
    let system_name: String?
    let system_version: String?
    let usage_data: Data?
    let total_sheets: Int
    let total_custom_icons: Int
    let items_in_documents: Int
    var user_id: UUID?
    
    init(id: UUID = UUID(uuidString: UIDevice.current.identifierForVendor?.uuidString ?? "\(UUID())") ?? UUID(), app_version: String? = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String, bundle_version: String? = Bundle.main.infoDictionary?["CFBundleVersion"] as? String, device_model: String? = UIDevice.current.model, device_identifier: String? = {
        var systemInfo = utsname()
        uname(&systemInfo)
        let machine = withUnsafePointer(to: &systemInfo.machine) {
            $0.withMemoryRebound(to: CChar.self, capacity: 1) {
                String(validatingUTF8: $0)
            }
        }
        return machine }(), system_name: String = UIDevice.current.systemName, system_version: String = UIDevice.current.systemVersion, usage_data: Data? = try? encoder.encode(getUsage()), total_sheets: Int = loadSheetArray().count - 1, total_custom_icons: Int = getCustomPECSAddresses().count, items_in_documents: Int = countItemsInDocuments(), user_id: UUID? = nil) {
        self.id = id
        self.app_version = app_version
        self.bundle_version = bundle_version
        self.device_model = device_model
        self.device_identifier = device_identifier
        self.system_name = system_name
        self.system_version = system_version
        self.usage_data = usage_data
        self.total_sheets = total_sheets
        self.total_custom_icons = total_custom_icons
        self.items_in_documents = items_in_documents
        self.user_id = user_id
    }
    
    static func == (lhs: UsageDataUpload, rhs: UsageDataUpload) -> Bool {
        return lhs.id == rhs.id
    }
}

struct SheetObject: Codable, Hashable {
    var currGrid: [GridSlot]
    var gridType: String
    var removedIcons: [IconObject]
    var completedIcons: [IconObject]?
    var label: String
    var currLabelIcon: String?
    
    init(currGrid: [GridSlot] = [GridSlot()], gridType: String = "label", removedIcons: [IconObject] = [], label: String = "Label") {
        self.currGrid = currGrid
        self.gridType = gridType
        self.removedIcons = removedIcons
        self.label = label
        self.currLabelIcon = nil
    }
    
    func getCurrSlot() -> Int {
        if gridType != "time" {
            return -1
        }
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mm a"
        let now = Date()
        var currSlotIndex = 0
        
        // Get the time components of the current date
        let currentComponents = calendar.dateComponents([.hour, .minute], from: now)
        
        // Filter dates that have the same time of day or earlier
        let filteredDates = updateCurrTimeToNow(currGrid)
            .filter {
                let objectComponents = calendar.dateComponents([.hour, .minute], from: $0.currTime)
                return (objectComponents.hour! < currentComponents.hour!) ||
                (objectComponents.hour! == currentComponents.hour! && objectComponents.minute! <= currentComponents.minute!)
            }
            .compactMap { formatter.string(from: $0.currTime) }
            .compactMap { formatter.date(from: $0) }
        
        if filteredDates.count < 1 {
            return 0
        }
        // Find the latest date from the filtered dates
        let latestDate = filteredDates.max()!
        
        for (index, object) in currGrid.enumerated() {
            //check if the date == latestDate
            if getTime(date: object.currTime) == getTime(date: latestDate) {
                currSlotIndex = index
            }
        }
        return currSlotIndex
        
    }
}


struct GridSlot: Codable, Hashable {
    var currTime: Date
    var currLabel: String
    var currIcons: [IconObject]
    
    init(currLabel: String = "First", currTime: Date = getCurrentTimeRoundedToHalfHour(), currIcons: [IconObject] = [IconObject(), IconObject(), IconObject(), IconObject()]){
        self.currLabel = currLabel
        self.currTime = currTime
        self.currIcons = currIcons
    }
    
    func hash(into hasher: inout Hasher) {
            hasher.combine(currTime)
            hasher.combine(currLabel)
            hasher.combine(currIcons)
        }
    func isEmpty() -> Bool {
        let icons = currIcons
        for (_, icon) in icons.enumerated() {
            if icon.currIcon != "plus.viewfinder" {
                return false
            }
        }
        return true
    }
}

struct IconObject: Codable, Hashable {
    var currLabel: String
    var currIcon: String
    var currDetails: [String]?
    
    init(currLabel: String = "icon", currIcon: String = "") {
        self.currLabel = currLabel
        self.currIcon = currIcon
        self.currDetails = []
    }
    
    func hash(into hasher: inout Hasher) {
            hasher.combine(currLabel)
            hasher.combine(currIcon)
        }
}

struct AppGridList: Codable {
    var currLabel: String
    var currIcons: [String]
    
    init(currLabel: String = "App Category", currIcons: [String] = allPECS) {
        self.currLabel = currLabel
        self.currIcons = currIcons
    }
}

struct UsageData: Codable, Identifiable {
    var id = UUID() // Unique identifier
    var date: Date //the day for which the usage data occured
    var data: [String] //the list of icons (or maybe actions in the future) that counted as usage
    
    init(date: Date = Date(), data: [String] = []) {
        self.date = date
        self.data = data
    }
}



//viewcontrollers and representables below

struct PHPickerView: UIViewControllerRepresentable {
    @Binding var selectedImage: UIImage?
    @Binding var isLoading: Bool
    
    func makeUIViewController(context: Context) -> PHPickerViewController {
        var configuration = PHPickerConfiguration()
        configuration.filter = .images
        let picker = PHPickerViewController(configuration: configuration)
        picker.delegate = context.coordinator
        return picker
    }
    
    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {
        // No update needed
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(parent: self)
    }
    
    class Coordinator: PHPickerViewControllerDelegate {
        let parent: PHPickerView
        
        init(parent: PHPickerView) {
            self.parent = parent
            self.parent.isLoading = true
        }
        
        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
            picker.dismiss(animated: true)
            
            guard let provider = results.first?.itemProvider else {
                self.parent.isLoading = false
                return
            }
            if provider.canLoadObject(ofClass: UIImage.self) {
                provider.loadObject(ofClass: UIImage.self) { image, _ in
                    guard let image = image as? UIImage else { return }
                    DispatchQueue.main.async {
                        withAnimation(.snappy) {
                            self.parent.selectedImage = image
                            self.parent.isLoading = false
                        }
                    }
                }
            }
        }
    }
}

struct DocumentImagePicker: UIViewControllerRepresentable {
    @Binding var selectedCustomImage: UIImage?
    @Binding var isLoading: Bool
    
    class Coordinator: NSObject, UIDocumentPickerDelegate {
        var parent: DocumentImagePicker
        
        init(parent: DocumentImagePicker) {
            self.parent = parent
            self.parent.isLoading = true
        }
        
        func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
            guard let url = urls.first, url.startAccessingSecurityScopedResource() else {
                return
            }
            defer {
                url.stopAccessingSecurityScopedResource()
            }
            do {
                let imageData = try Data(contentsOf: url)
                let image = UIImage(data: imageData)
                withAnimation(.snappy) {
                    parent.selectedCustomImage = image
                    parent.isLoading = false
                }
            } catch {
                currSessionLog.append("Error loading image: \(error.localizedDescription)")
            }
        }
        
        func documentPickerWasCancelled(_ controller: UIDocumentPickerViewController) {
            parent.isLoading = false
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(parent: self)
    }
    
    func makeUIViewController(context: Context) -> UIViewController {
        let documentPicker = UIDocumentPickerViewController(forOpeningContentTypes: [UTType.image])
        documentPicker.delegate = context.coordinator
        documentPicker.allowsMultipleSelection = false
        return documentPicker
    }
    
    func updateUIViewController(_ uiViewController: UIViewController, context: Context) {
        // No update needed
    }
}

struct CameraPickerView: UIViewControllerRepresentable {
    @Binding var selectedImage: UIImage?
    @Binding var isLoading: Bool

    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
        var parent: CameraPickerView

        init(parent: CameraPickerView) {
            self.parent = parent
            self.parent.isLoading = true
        }
        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            if let image = info[.originalImage] as? UIImage {
                withAnimation(.snappy) {
                    parent.selectedImage = image
                }
            }
            parent.isLoading = false
            picker.dismiss(animated: true, completion: nil)
        }

        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            parent.isLoading = false
            picker.dismiss(animated: true, completion: nil)
        }
    }

    func makeCoordinator() -> Coordinator {
        return Coordinator(parent: self)
    }

    func makeUIViewController(context: Context) -> UIImagePickerController {
        let imagePicker = UIImagePickerController()
        imagePicker.delegate = context.coordinator
        imagePicker.sourceType = .camera
        return imagePicker
    }

    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {
        //nothing to update
    }
}

struct MailView: UIViewControllerRepresentable {
    @Environment(\.presentationMode) var presentation
    @Binding var result: Result<MFMailComposeResult, Error>?
    
    let email: String
    let subject: String
    @Binding var body: String
    
    class Coordinator: NSObject, MFMailComposeViewControllerDelegate {
        @Binding var presentation: PresentationMode
        @Binding var result: Result<MFMailComposeResult, Error>?
        
        init(presentation: Binding<PresentationMode>, result: Binding<Result<MFMailComposeResult, Error>?>) {
            _presentation = presentation
            _result = result
        }
        
        func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) {
            defer { $presentation.wrappedValue.dismiss() }
            guard error == nil else {
                self.result = .failure(error!)
                return
            }
            self.result = .success(result)
        }
    }
    
    func makeCoordinator() -> Coordinator {
        return Coordinator(presentation: presentation, result: $result)
    }
    
    func makeUIViewController(context: Context) -> MFMailComposeViewController {
        print("recieved body: \(body)")
        let vc = MFMailComposeViewController()
        vc.mailComposeDelegate = context.coordinator
        vc.setToRecipients([email])
        vc.setSubject(subject)
        vc.setMessageBody(body, isHTML: true)
        print("set body to: \(body)")
        
        return vc
    }
    
    func updateUIViewController(_ uiViewController: MFMailComposeViewController, context: Context) {}
}

struct DeviceRotationViewModifier: ViewModifier {
    let action: (UIDeviceOrientation) -> Void

    func body(content: Content) -> some View {
        content
            .onAppear()
            .onReceive(NotificationCenter.default.publisher(for: UIDevice.orientationDidChangeNotification)) { _ in
                action(UIDevice.current.orientation)
            }
    }
}

final class VolumeObserver: ObservableObject {
    
    @Published var volume: Float = AVAudioSession.sharedInstance().outputVolume
    
    // Audio session object
    private let session = AVAudioSession.sharedInstance()
    
    // Observer
    private var progressObserver: NSKeyValueObservation!
    
    func subscribe() {
        do {
            try AVAudioSession.sharedInstance().setCategory(AVAudioSession.Category.ambient)
            try session.setActive(true, options: .notifyOthersOnDeactivation)
        } catch {}
        
        progressObserver = session.observe(\.outputVolume) { [self] (session, value) in
            DispatchQueue.main.async {
                self.volume = session.outputVolume
            }
        }
    }
    
    func unsubscribe() {
        self.progressObserver.invalidate()
    }
    
    init() {
        subscribe()
    }
}

struct FavoritesFolderPreviewView: View {
    @Environment(\.horizontalSizeClass) var horizontalSizeClass
    @Binding var icons: [String]
    
    var body: some View {
        VStack {
            ZStack {
                //                LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: 0), count: 3), spacing: 0) {
                //                    ForEach(icons, id: \.self) { icon in
                //                        if UIImage(named: icon) == nil {
                //                            getCustomIcon(icon)
                //                                .scaledToFill()
                //                                .clipShape(RoundedRectangle(cornerRadius: 2))
                //                                .overlay(
                //                                    RoundedRectangle(cornerRadius: 2)
                //                                        .stroke(.black, linewidth: 0.5)
                //                                )
                //                                .foregroundStyle(.primary)
                //                        } else {
                //                            Image(icon)
                //                                .resizable()
                //                                .scaledToFill()
                //                                .clipShape(RoundedRectangle(cornerRadius: 2))
                //                                .overlay(
                //                                    RoundedRectangle(cornerRadius: 2)
                //                                        .stroke(.black, linewidth: 0.5)
                //                                )
                //                                .foregroundStyle(.primary)
                //                        }
                //                    }
                //                }
                if UIImage(named: icons[0]) == nil {
                    getCustomIcon(icons[0])
                        .scaledToFill()
                } else {
                    Image(icons[0])
                        .resizable()
                        .scaledToFill()
                }
            }.mask(
                Image(systemName: "folder.fill")
                    .resizable()
                    .scaledToFit()
            )
            .overlay(
                ZStack {
                    Image(systemName: "folder")
                        .resizable()
                        .scaledToFit()
                        .foregroundStyle(.orange)
                    Image(systemName: "folder.fill")
                        .resizable()
                        .scaledToFit()
                        .foregroundStyle(.orange)
                        .opacity(0.3)
                }
            )
            Text("Most Used")
                .font(.system(size: horizontalSizeClass == .compact ? 15 : 25, weight: .bold, design: .rounded))
                .lineLimit(1)
                .foregroundStyle(.orange)
        }
    }
}

struct FolderPreviewView: View, Equatable {
    @Environment(\.horizontalSizeClass) var horizontalSizeClass
    var currCommunicationBoard: [[String]]
    var index: Int
    var altText: String? = nil
    var folderColor: Color = .blue
    
    var body: some View {
        VStack {
            ZStack {
//                LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: 0), count: 3), spacing: 0) {
                    //                    if currCommunicationBoard[index].count < 9 {
                    //                        ForEach(0..<(8 - currCommunicationBoard[index].count), id: \.self) { icon in
                    //                            Image(systemName: "square")
                    //                                .resizable()
                    //                                .scaledToFill()
                    //                                .foregroundStyle(.clear)
                    //                        }
                    //                    }
                    //                    ForEach(currCommunicationBoard[index].dropFirst().prefix(9), id: \.self) { icon in
                    //                        if UIImage(named: icon) == nil {
                    //                            getCustomIcon(icon)
                    //                                .scaledToFill()
                    //                                .clipShape(RoundedRectangle(cornerRadius: 2))
                    //                                .overlay(
                    //                                    RoundedRectangle(cornerRadius: 2)
                    //                                        .stroke(.black, linewidth: 0.5)
                    //                                )
                    //                                .foregroundStyle(.primary)
                    //                        } else {
                    //                            Image(icon)
                    //                                .resizable()
                    //                                .scaledToFill()
                    //                                .clipShape(RoundedRectangle(cornerRadius: 2))
                    //                                .overlay(
                    //                                    RoundedRectangle(cornerRadius: 2)
                    //                                        .stroke(.black, linewidth: 0.5)
                    //                                )
                    //                                .foregroundStyle(.primary)
                    //                        }
                    //                    }
//                }
                if UIImage(named: currCommunicationBoard[index][1]) == nil {
                    getCustomIcon(currCommunicationBoard[index][1])
                        .scaledToFill()
                } else {
                    Image(currCommunicationBoard[index][1])
                        .resizable()
                        .scaledToFill()
                }
            }.mask(
                Image(systemName: "folder.fill")
                    .resizable()
                    .scaledToFit()
            )
            .overlay(
                ZStack {
                    Image(systemName: "folder")
                        .resizable()
                        .scaledToFit()
                        .foregroundStyle(.blue)
                    Image(systemName: "folder.fill")
                        .resizable()
                        .scaledToFit()
                        .foregroundStyle(.blue)
                        .opacity(0.3)
                }
            )
            Text(altText == nil ? currCommunicationBoard[index][0] : altText!)
                .font(.system(size: horizontalSizeClass == .compact ? 15 : 25, weight: .bold, design: .rounded))
                .lineLimit(1)
                .foregroundStyle(.primary)
        }
    }
    
    static func == (lhs: FolderPreviewView, rhs: FolderPreviewView) -> Bool {
        // Compare only the relevant properties for equality
        return lhs.currCommunicationBoard == rhs.currCommunicationBoard && lhs.index == rhs.index
    }
}

struct CustomIconView: View, Equatable {
    @Environment(\.horizontalSizeClass) var horizontalSizeClass
    let selectedCustomImage: Image
    let currCustomIconText: String
    let noImage: Bool
    var body: some View {
        RoundedRectangle(cornerRadius: 16)
            .stroke(Color.black, lineWidth: 3)
            .background(
                RoundedRectangle(cornerRadius: 20)
                    .fill(Color.white)
            )
            .aspectRatio(1, contentMode: .fill)
            .clipShape(RoundedRectangle(cornerRadius: 20))
            .overlay(
                VStack {
                    if !currCustomIconText.isEmpty && !noImage {
                        Spacer()
                    }
                    if !noImage /* check to see if the image is not plus.viewfinder */ {
                        RoundedRectangle(cornerRadius: 20)
                            .foregroundStyle(.clear)
                            .background (
                                selectedCustomImage
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                            )
                            .aspectRatio(1, contentMode: .fit)
                            .clipShape(RoundedRectangle(cornerRadius: 20))
                    }
                    if !currCustomIconText.isEmpty {
                        if !noImage {
                            Spacer()
                        }
                        Text(currCustomIconText)
                            .lineLimit(1)
                            .multilineTextAlignment(.center)
                            .font(.system(size: noImage ? 200 : (horizontalSizeClass == .compact ? 45 : 90), weight: .medium, design: .rounded))
                            .minimumScaleFactor(0.5)
                            .foregroundStyle(.black)
                            .padding(.leading)
                            .padding(.trailing)
                            .padding(.bottom, 3)
                    }
                }
            )
            .scaledToFit()
            .ignoresSafeArea()
    }
    
    static func == (lhs: CustomIconView, rhs: CustomIconView) -> Bool {
        // Compare only the relevant properties for equality
        return lhs.selectedCustomImage == rhs.selectedCustomImage && lhs.currCustomIconText == rhs.currCustomIconText
    }
    
}

struct ModImageView: View {
    
    @Environment(\.horizontalSizeClass) var horizontalSizeClass
    
    @Binding var currSheet: SheetObject
    @Binding var modListIndex: Int
    @Binding var modSlotIndex: Int
    @State var hasDetails = false
    
    var body: some View {
        
        if modListIndex >= currSheet.currGrid.count {
            Image(systemName: "text.below.photo")
                .resizable()
                .scaledToFit()
                .padding()
        } else {
            if UIImage(named: currSheet.currGrid[modListIndex].currIcons[modSlotIndex].currIcon) == nil {
                if horizontalSizeClass == .compact {
                    getCustomIcon(currSheet.currGrid[modListIndex].currIcons[modSlotIndex].currIcon)
                        .scaledToFit()
                        .clipShape(RoundedRectangle(cornerRadius: hasDetails ? 30 : 15))
                        .overlay(
                            RoundedRectangle(cornerRadius: hasDetails ? 30 : 15)
                                .stroke(.black, lineWidth: hasDetails ? 10 : 6)
                        )
                        .padding()
                } else {
                    getCustomIcon(currSheet.currGrid[modListIndex].currIcons[modSlotIndex].currIcon, large: true)
                        .scaledToFit()
                        .clipShape(RoundedRectangle(cornerRadius: hasDetails ? 30 : 15))
                        .overlay(
                            RoundedRectangle(cornerRadius: hasDetails ? 30 : 15)
                                .stroke(.black, lineWidth: hasDetails ? 20 : 10)
                        )
                        .padding()
                }
            } else {
                Image(currSheet.currGrid[modListIndex].currIcons[modSlotIndex].currIcon)
                    .resizable()
                    .scaledToFit()
                    .clipShape(RoundedRectangle(cornerRadius: hasDetails ? 30 : 15))
                    .overlay(
                        RoundedRectangle(cornerRadius: hasDetails ? 30 : 15)
                            .stroke(.black, lineWidth: hasDetails ? (horizontalSizeClass == .compact ? 10 : 20) : (horizontalSizeClass == .compact ? 6 : 10))
                    )
                    .padding()
            }
        }
    }
}
class NetworkMonitor: ObservableObject {
    private var monitor: NWPathMonitor
    private var queue: DispatchQueue
    @Published var isConnected: Bool = false

    init() {
        self.monitor = NWPathMonitor()
        self.queue = DispatchQueue(label: "NetworkMonitor")
        self.monitor.pathUpdateHandler = { path in
            DispatchQueue.main.async {
                self.isConnected = path.status == .satisfied
            }
        }
        self.monitor.start(queue: self.queue)
    }

    deinit {
        self.monitor.cancel()
    }
}


class SpeechSynthesizerDelegate: NSObject, AVSpeechSynthesizerDelegate, ObservableObject {
    @Published var progress: Double = 0.0
    @Published var isSpeaking: Bool = false
    @Published var isPaused: Bool = false
    private var totalCharacters: Int = 0
    let audioSession = AVAudioSession.sharedInstance()
    @AppStorage("currVoiceRatio") private var currVoiceRatio: Double = 1.0
    @AppStorage("currVoice") private var currVoice: String = "com.apple.ttsbundle.Daniel-compact"
    private var synthesizer = AVSpeechSynthesizer()
    
    override init() {
        super.init()
        synthesizer.delegate = self
    }
    
    func speak(_ string: String) {
        guard defaults.bool(forKey: "speakOn") else { return }
        do {
            try audioSession.setCategory(.playback, options: [.duckOthers])
            try audioSession.setActive(true)
            let utterance = AVSpeechUtterance(string: extractKey(from: string))
            utterance.voice = AVSpeechSynthesisVoice(identifier: currVoice) ?? AVSpeechSynthesisVoice()
            utterance.rate = Float(currVoiceRatio / 2)
            synthesizer.speak(utterance)
        } catch {
            currSessionLog.append("Error setting up audio session: \(error)")
            return
        }
    }
    
    func stopSpeaking(boundary: AVSpeechBoundary = .immediate) {
        //    speechStore.audioObjects.removeAll()
        guard synthesizer.isSpeaking else { return }
        synthesizer.stopSpeaking(at: boundary)
    }
    
    func pauseSpeaking(at: AVSpeechBoundary) {
        synthesizer.pauseSpeaking(at: at)
    }
    
    func continueSpeaking() {
        synthesizer.continueSpeaking()
    }
    
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didStart utterance: AVSpeechUtterance) {
        totalCharacters = utterance.speechString.count
        progress = 0.0
        isSpeaking = true
        isPaused = false
    }
    
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance) {
        progress = 1.0
        isSpeaking = false
        isPaused = false
    }
    
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didPause utterance: AVSpeechUtterance) {
        isPaused = true
    }
    
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didContinue utterance: AVSpeechUtterance) {
        isPaused = false
        isSpeaking = true
    }
    
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didCancel utterance: AVSpeechUtterance) {
        progress = 0.0
        isSpeaking = false
        isPaused = false
    }
    
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, willSpeakRangeOfSpeechString characterRange: NSRange, utterance: AVSpeechUtterance) {
        progress = Double(characterRange.location + characterRange.length) / Double(totalCharacters)
    }
}

public struct ProgressIndicatorView: View {
    
    public enum IndicatorType {
        case `default`(progress: Binding<CGFloat>)
        case bar(progress: Binding<CGFloat>, backgroundColor: Color = .clear)
        case impulseBar(progress: Binding<CGFloat>, backgroundColor: Color = .clear)
        case dashBar(progress: Binding<CGFloat>, numberOfItems: Int = 8, backgroundColor: Color = .clear)
        case circle(progress: Binding<CGFloat>, lineWidth: CGFloat, strokeColor: Color, backgroundColor: Color = .clear)
    }
    
    @Binding var isVisible: Bool
    var type: IndicatorType
    
    public init(isVisible: Binding<Bool>, type: IndicatorType) {
        self._isVisible = isVisible
        self.type = type
    }
    
    public var body: some View {
        if isVisible {
            indicator
        } else {
            EmptyView()
        }
    }
    
    private var indicator: some View {
        ZStack {
            switch type {
            case .bar(let progress, let backgroundColor):
                BarView(progress: progress, backgroundColor: backgroundColor)
            case .impulseBar(let progress, let backgroundColor):
                ImpulseBarView(progress: progress, backgroundColor: backgroundColor)
            case .`default`(let progress):
                DefaultSectorView(progress: progress)
            case .circle(let progress, let lineWidth, let strokeColor, let backgroundColor):
                CircleView(progress: progress, lineWidth: lineWidth, strokeColor: strokeColor, backgroundColor: backgroundColor)
            case .dashBar(let progress, let numberOfItems, let backgroundColor):
                DashBarView(progress: progress, numberOfItems: numberOfItems, backgroundColor: backgroundColor)
            }
        }
    }
}

struct SizeGetter: ViewModifier {
    @Binding var size: CGSize

    func body(content: Content) -> some View {
        content
            .background(
                GeometryReader { proxy -> Color in
                    if proxy.size != self.size {
                        DispatchQueue.main.async {
                            self.size = proxy.size
                        }
                    }
                    return Color.clear
                }
            )
    }
}

struct SheetDropDelegate : DropDelegate {
    
    let item : SheetObject
    @Binding var items : [SheetObject]
    @Binding var draggedItem : SheetObject?
    func performDrop(info: DropInfo) -> Bool {
        return true
    }
    func dropEntered(info: DropInfo) {
        guard let draggedItem = self.draggedItem else {
            return
        }
        if draggedItem != item {
            let from = items.firstIndex(of: draggedItem)!
            let to = items.firstIndex(of: item)!
            withAnimation(.snappy) {
                self.items.move(fromOffsets: IndexSet(integer: from), toOffset: to > from ? to + 1 : to)
            }
        }
    }
}

struct TextDropDelegate : DropDelegate {
    
    let item : String
    @Binding var items : [String]
    @Binding var draggedItem : String?
    func performDrop(info: DropInfo) -> Bool {
        return true
    }
    func dropEntered(info: DropInfo) {
        guard let draggedItem = self.draggedItem else {
            return
        }
        if draggedItem != item {
            let from = items.firstIndex(of: draggedItem)!
            let to = items.firstIndex(of: item)!
            withAnimation(.snappy) {
                self.items.move(fromOffsets: IndexSet(integer: from), toOffset: to > from ? to + 1 : to)
            }
        }
    }
}

struct TextArrayDropDelegate: DropDelegate {
    let item: String
    @Binding var items: [String]
    @Binding var backgroundItems: [[String]]
    @Binding var draggedItem: String?
    @Binding var unlockButtons: Bool
    @AppStorage("buttonsOn") private var lockButtonsOn: Bool = false
    
    func performDrop(info: DropInfo) -> Bool {
        return true
    }
    
    func dropEntered(info: DropInfo) {
        if !lockButtonsOn || unlockButtons {
            guard let draggedItem = self.draggedItem else {
                return
            }
            if draggedItem != item {
                if let from = items.firstIndex(of: draggedItem),
                   let to = items.firstIndex(of: item) {
                    withAnimation(.snappy) {
                        self.items.move(fromOffsets: IndexSet(integer: from), toOffset: to > from ? to + 1 : to)
                        self.backgroundItems.move(fromOffsets: IndexSet(integer: from), toOffset: to > from ? to + 1 : to)
                    }
                }
            }
        } else {return}
    }
}

public final class ImageStore: ObservableObject {
    public var openAIClient: OpenAIProtocol
    
    @Published var images: [ImagesResult.Image] = []
    
    public init(
        openAIClient: OpenAIProtocol
    ) {
        self.openAIClient = openAIClient
    }
    
    @MainActor
    func images(query: ImagesQuery) async {
        images.removeAll()
        do {
            let response = try await openAIClient.images(query: query)
            images = response.data
        } catch {
            // TODO: Better error handling
            currSessionLog.append(error.localizedDescription)
        }
    }
}

public final class SpeechStore: ObservableObject {
    public var openAIClient: OpenAIProtocol
    
    @Published var audioObjects: [AudioObject] = []
    
    public init(
        openAIClient: OpenAIProtocol
    ) {
        self.openAIClient = openAIClient
    }
    
    struct AudioObject: Identifiable {
        let id = UUID()
        let prompt: String
        let audioPlayer: AVAudioPlayer?
        let originResponse: AudioSpeechResult
        let format: String
    }
    
    @MainActor
    func createSpeech(_ query: AudioSpeechQuery) async {
        let input = query.input
        guard !input.isEmpty else { return }
        do {
            let response = try await openAIClient.audioCreateSpeech(query: query)
            let data = response.audio
            let player = try? AVAudioPlayer(data: data)
            if let avPLayer = player {avPLayer.play()}
            let audioObject = AudioObject(prompt: input,
                                          audioPlayer: player,
                                          originResponse: response,
                                          format: query.responseFormat?.rawValue ?? AudioSpeechQuery.AudioSpeechResponseFormat.mp3.rawValue)
            audioObjects.append(audioObject)
            
        } catch {
            currSessionLog.append(error.localizedDescription)
        }
    }
    
    func getFileInDocumentsDirectory(_ data: Data, fileName: String, _ completion: @escaping (URL) -> Void) {
        if let fileURL = try? FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: true) {
            let saveURL = fileURL.appendingPathComponent(fileName)
            do {
                try data.write(to: saveURL)
                completion(saveURL)
            } catch {
                currSessionLog.append(error.localizedDescription)
            }
        }
    }
}

struct ActivityViewController: UIViewControllerRepresentable {
    
    var activityItems: [Any]
    var applicationActivities: [UIActivity]? = nil
    
    func makeUIViewController(context: UIViewControllerRepresentableContext<ActivityViewController>) -> UIActivityViewController {
        let controller = UIActivityViewController(activityItems: activityItems, applicationActivities: applicationActivities)
        return controller
    }
    
    func updateUIViewController(_ uiViewController: UIActivityViewController, context: UIViewControllerRepresentableContext<ActivityViewController>) {}
    
}


//extensions below here>>>>>>>>

extension Collection {
    // Returns the element at the specified index if it is within bounds, otherwise nil.
    subscript (safe index: Index) -> Element? {
        return indices.contains(index) ? self[index] : nil
    }
}


extension String {
    func toUppercaseAtSentenceBoundary() -> String {
        var result = ""
        self.uppercased().enumerateSubstrings(in: self.startIndex..<self.endIndex, options: .bySentences) { (sub, _, _, _)  in
            result += String(sub!.prefix(1))
            result += String(sub!.dropFirst(1)).lowercased()
        }
        return result as String
    }
}


extension View {
    func onRotate(perform action: @escaping (UIDeviceOrientation) -> Void) -> some View {
        self.modifier(DeviceRotationViewModifier(action: action))
    }
    
    func asImage() -> UIImage {
        let controller = UIHostingController(rootView: self)
        
        // Locate far out of screen
        controller.view.frame = CGRect(x: CGFloat(Int.max), y: 0, width: 1024, height: 1024)
        
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let window = windowScene.windows.first {
            window.rootViewController?.view.addSubview(controller.view)
        } else {
            // Handle the error case where no window is available
            return UIImage()
        }
        
        let size = controller.sizeThatFits(in: UIScreen.main.bounds.size)
        controller.view.bounds = CGRect(origin: .zero, size: size)
        controller.view.backgroundColor = UIColor.clear
        controller.view.sizeToFit()
        
        let image = UIImage(view: controller.view)
        controller.view.removeFromSuperview()
        return image
    }
    
    public func sizeGetter(_ size: Binding<CGSize>) -> some View {
        modifier(SizeGetter(size: size))
    }
}

extension UIImage {
    var asImage: Image {
        Image(uiImage: self)
    }
    
    convenience init(view: UIView) {
        UIGraphicsBeginImageContextWithOptions(view.bounds.size, view.isOpaque, 0.0)
        defer { UIGraphicsEndImageContext() }
        view.drawHierarchy(in: view.bounds, afterScreenUpdates: true)
        let image = UIGraphicsGetImageFromCurrentImageContext()
        self.init(cgImage: (image?.cgImage)!)
    }
    
    func resize(to size: CGSize) -> UIImage? {
        UIGraphicsBeginImageContextWithOptions(size, false, 1.0)
        self.draw(in: CGRect(origin: .zero, size: size))
        let resizedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return resizedImage
    }
    
    func toBuffer() -> CVPixelBuffer? {
        guard let image = self.cgImage else { return nil }
        
        let frameSize = CGSize(width: image.width, height: image.height)
        
        var pixelBuffer: CVPixelBuffer?
        let status = CVPixelBufferCreate(kCFAllocatorDefault,
                                         Int(frameSize.width),
                                         Int(frameSize.height),
                                         kCVPixelFormatType_32ARGB,
                                         nil,
                                         &pixelBuffer)
        
        guard status == kCVReturnSuccess, let buffer = pixelBuffer else { return nil }
        
        CVPixelBufferLockBaseAddress(buffer, CVPixelBufferLockFlags(rawValue: 0))
        let pixelData = CVPixelBufferGetBaseAddress(buffer)
        
        let rgbColorSpace = CGColorSpaceCreateDeviceRGB()
        guard let context = CGContext(data: pixelData,
                                      width: Int(frameSize.width),
                                      height: Int(frameSize.height),
                                      bitsPerComponent: 8,
                                      bytesPerRow: CVPixelBufferGetBytesPerRow(buffer),
                                      space: rgbColorSpace,
                                      bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue) else {
            CVPixelBufferUnlockBaseAddress(buffer, CVPixelBufferLockFlags(rawValue: 0))
            return nil
        }
        
        context.translateBy(x: 0, y: frameSize.height)
        context.scaleBy(x: 1.0, y: -1.0)
        
        context.draw(image, in: CGRect(origin: .zero, size: frameSize))
        
        CVPixelBufferUnlockBaseAddress(buffer, CVPixelBufferLockFlags(rawValue: 0))
        
        return buffer
    }
    
    public static var writableTypeIdentifiersForItemProvider: [String] {
        return [UTType.image.identifier]
    }
    
    public func loadData(withTypeIdentifier typeIdentifier: String, forItemProviderCompletionHandler completionHandler: @escaping (Data?, Error?) -> Void) -> Progress? {
        guard let data = self.pngData() else {
            completionHandler(nil, NSError(domain: "ImageEncoding", code: -1, userInfo: nil))
            return nil
        }
        completionHandler(data, nil)
        return nil
    }
    
    public static var readableTypeIdentifiersForItemProvider: [String] {
        return [UTType.image.identifier]
    }
    
    public static func object(withItemProviderData data: Data, typeIdentifier: String) throws -> Self {
        guard let image = UIImage(data: data) else {
            throw NSError(domain: "ImageDecoding", code: -1, userInfo: nil)
        }
        return image as! Self
    }
}
